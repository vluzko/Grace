// DEPRECATED //

use std::collections::HashMap;
extern crate itertools;

use scoping::Context;
use typing::Type;
use llr::{
    WASMModule,
    WASMFunc,
    WASM
};
use compiler_layers::CompiledModule;

pub trait ToBytecode {
    /// Generate WAST bytecode from an AST
    /// CONVENTIONS:
    ///     Generated bytecode should not start or end with a newline, *except* for modules / other
    ///     top level functions. Starting and ending newlines are the responsibility of the parent
    ///     node. We don't have to do it this way, but it's important to have a single convention.
    ///     Nodes *do* need to handle newlines at the start and end of their *children*, obviously.
    fn generate_bytecode(&self, context: &Context) -> String;
}

impl ToBytecode for WASMModule {
    fn generate_bytecode(&self, context: &Context) -> String {
        panic!()
    }
}

impl ToBytecode for WASMFunc {
    fn generate_bytecode(&self, context: &Context) -> String {
        panic!()
    }
}

impl ToBytecode for WASM {
    fn generate_bytecode(&self, context: &Context) -> String {
        panic!()
    }
}

// impl ToBytecode for Node<Module> {

//     /// Generate bytecode for a module.
//     /// Is this code unbelievably ugly? Yes. Can I think of an easy way to make it prettier? No.
//     fn generate_bytecode(&self, context: &Context2) -> String {
//         let mut imports = vec!();
//         for import in &self.data.imports {
//             let import_stmt = context.get_declaration(self.scope, &import.path.get(0).unwrap()).unwrap();
//             let import_type = context.type_map.get(&import_stmt.get_id()).unwrap();
//             for value in &import.values {
//                 let mut ident_vec = import.path[1..].to_vec().clone();
//                 ident_vec.push(value.clone());
//                 let func_type = import_type.resolve_nested_record(&ident_vec);
//                 let module_name = CompiledModule::get_internal_module_name(&import.path);
//                 let type_str = func_type.wast_name();
//                 let import_stmt = format!("(import \"{mod}\" \"{func}\" (func $.{mod}.{func} {type}))", 
//                     mod=module_name, 
//                     func=value.name,
//                     type=type_str
//                 );
//                 imports.push(import_stmt);
//             }
//         }

//         let decls = self.data.declarations.iter().map(|x| x.generate_bytecode(context));
//         let import_str = itertools::join(imports.iter(), "\n");
//         let joined = itertools::join(decls, "\n");
//         return format!("(module\n\
//         (import \"memory_management\" \"alloc_words\" (func $.memory_management.alloc_words (param $a i32) (result i32)))\n\
//         (import \"memory_management\" \"free_chunk\" (func $.memory_management.free_chunk (param $a i32) (result i32)))\n\
//         (import \"memory_management\" \"copy_many\" (func $.memory_management.copy_many (param $a i32) (param $b i32) (param $size i32) (result i32)))\n\
//         (import \"memory_management\" \"mem\" (memory (;0;) 1))\n\
//         {}\n\
//         {}\n)\n", import_str, joined).to_string();
//     }
// }



#[cfg(test)]
mod tests {

}
