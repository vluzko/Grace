//! Helper functions used throughout code.
use std::collections::BTreeSet;
use std::collections::HashMap;
use std::collections::HashSet;
use std::fmt::Debug;
use std::hash::Hash;
use std::sync::atomic::{AtomicUsize, Ordering};

pub fn c_int<T>(a: &HashSet<T>, b: &HashSet<T>) -> HashSet<T>
where
    T: Eq,
    T: Hash,
    T: Clone,
{
    let int = a.intersection(b);
    int.into_iter().cloned().collect()
}

/// Take the union of two hashsets, cloning elements from both and consuming neither set.
pub fn c_union<T>(a: &HashSet<T>, b: &HashSet<T>) -> HashSet<T>
where
    T: Eq,
    T: Hash,
    T: Clone,
{
    let union = a.union(b);
    union.into_iter().cloned().collect()
}

/// Take the union of two hashsets, moving elements out of the second. Both original sets are consumed.
pub fn m_union<T>(mut a: HashSet<T>, b: HashSet<T>) -> HashSet<T>
where
    T: Eq,
    T: Hash,
{
    for element in b.into_iter() {
        a.insert(element);
    }
    a
}

/// Take the union of two btreesets, moving elements out of the second. Both original sets are consumed.
pub fn m_bt_union<T>(mut a: BTreeSet<T>, b: BTreeSet<T>) -> BTreeSet<T>
where
    T: Eq,
    T: Ord,
{
    for element in b.into_iter() {
        a.insert(element);
    }
    a
}

/// Take the union of two BTreeSets, consuming both.
pub fn mb_union<T>(mut a: BTreeSet<T>, b: BTreeSet<T>) -> BTreeSet<T>
where
    T: Eq,
    T: Ord,
{
    for element in b.into_iter() {
        a.insert(element);
    }
    a
}

/// Take the union of two vectors, without consuming either.
pub fn vec_c_union<T>(a: &[T], b: &[T]) -> Vec<T>
where
    T: Eq,
    T: Clone,
{
    let mut new_vec: Vec<T> = a.to_vec();
    for element in b.iter() {
        if !new_vec.contains(element) {
            new_vec.push((*element).clone());
        }
    }
    new_vec
}

/// Take the intersection of two vectors, without consuming either.
pub fn vec_c_int<T>(a: &[T], b: &[T]) -> Vec<T>
where
    T: Eq,
    T: Clone,
{
    let mut new_vec: Vec<T> = vec![];
    for element in a.iter() {
        if b.contains(element) {
            new_vec.push((*element).clone());
        }
    }
    new_vec
}

/// Append vec `b` to vec `a` and return the result, consuming both.
pub fn join<T>(mut a: Vec<T>, mut b: Vec<T>) -> Vec<T> {
    a.append(&mut b);
    a
}

/// Unzip a vector of two tuples into a tuple of vectors.
pub fn unzip_vec<S, T>(a: Vec<(S, T)>) -> (Vec<S>, Vec<T>) {
    let mut ss = Vec::with_capacity(a.len());
    let mut ts = Vec::with_capacity(a.len());
    for (s, t) in a.into_iter() {
        ss.push(s);
        ts.push(t);
    }
    (ss, ts)
}

pub fn vec_subset<T>(a: &[T], b: &[T]) -> bool
where
    T: Eq,
    T: Clone,
{
    for element in a.iter() {
        if !b.contains(element) {
            return false;
        }
    }
    true
}

pub fn extend_map<K, V>(mut a: HashMap<K, V>, b: HashMap<K, V>) -> HashMap<K, V>
where
    V: Eq,
    K: Hash,
    K: Eq,
    K: Debug,
    V: Debug,
{
    for (k, v) in b.into_iter() {
        // clippy is wrong, we can't refactor this easily.
        #[allow(clippy::map_entry)]
        if a.contains_key(&k) {
            if a.get(&k) != Some(&v) {
                panic!("Duplicate key found:\n {:?}\n {:?}", v, a.get(&k));
            }
        } else {
            a.insert(k, v);
        }
    }
    a
}

macro_rules! generate_counter {
    ($name:ident, $type:ident) => {
        /// Generated by the `simple-counter` crate.
        #[allow(non_snake_case)]
        pub mod $name {
            use std::cell::Cell;

            thread_local!(
                static COUNTER: Cell<$type> = Cell::new(1);
            );

            pub fn next() -> $type {
                COUNTER.with(|cell| {
                    let n = cell.get();
                    cell.set(n + 1);
                    n
                })
            }

            #[allow(dead_code)]
            pub fn set(n: $type) {
                COUNTER.with(|cell| cell.set(n));
            }

            #[allow(dead_code)]
            pub fn reset() {
                COUNTER.with(|cell| cell.set(1));
            }
        }
    };
}

static NODE_ID_COUNTER: AtomicUsize = AtomicUsize::new(0);
// static SCOPE_ID_COUNTER: AtomicUsize = AtomicUsize::new(0);
generate_counter!(SCOPE_ID_COUNTER, usize);
static MODULE_ID_COUNTER: AtomicUsize = AtomicUsize::new(0);
static LOCAL_VAR_ID_COUNTER: AtomicUsize = AtomicUsize::new(0);
static GRADUAL_TYPE_COUNTER: AtomicUsize = AtomicUsize::new(0);

// Generate a globally unique node ID.
pub fn get_next_id() -> usize {
    NODE_ID_COUNTER.fetch_add(1, Ordering::SeqCst)
}

/// Generate a globally unique scope ID.
pub fn get_next_scope_id() -> usize {
    SCOPE_ID_COUNTER::next()
}

/// Generate a globally unique module ID.
pub fn get_next_module_id() -> usize {
    MODULE_ID_COUNTER.fetch_add(1, Ordering::SeqCst)
}

/// Generate a globally unique variable ID.
pub fn get_next_var() -> usize {
    LOCAL_VAR_ID_COUNTER.fetch_add(1, Ordering::SeqCst)
}

/// Generate a globally unique gradual type ID.
pub fn get_next_grad() -> usize {
    GRADUAL_TYPE_COUNTER.fetch_add(1, Ordering::SeqCst)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_c_int() {
        let vec1 = vec![1, 2, 3];
        let vec2 = vec![3, 4, 5];
        let merged = vec_c_int(&vec1, &vec2);
        assert_eq!(merged, vec![3]);
    }
}
